function parseMultiFormatData() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const inputSheet = ss.getSheetByName("シート1");
  const outputSheet = ss.getSheetByName("抽出結果") || ss.insertSheet("抽出結果");

  let rawText = inputSheet.getRange("A1").getValue();
  // Normalize different yen symbols to a standard form so regex patterns match
  rawText = rawText.replace(/[\\￥]/g, '¥');
  // ヘッダー「摘要 数量 単価 明細金額」が同一行に存在する場合は除去
  rawText = rawText.replace(/摘要\s+数量\s+単価\s+明細金額\s+/g, '');
  // 改行が入っている場合でも1行にまとめてから日付毎に改行を補完
  const dateBlock = /(\d{4}\/\d{2}\/\d{2}\s+[^¥]+?\s+¥[\d,]+\s+\d+(?:,\d+)*\s+¥[\d,]+)/g;
  rawText = rawText.replace(dateBlock, m => m.replace(/\r?\n/g, ' ') + '\n');
  const lines = rawText
    .split(/\r?\n/)
    .map(line => line.trim())
    .filter(line => line && !/^[-]+$/.test(line));
  Logger.log("=== 入力行の解析開始 ===");
  lines.forEach((l, idx) => Logger.log(`行${idx + 1}: ${l}`));

  let date = "", client = "", project = "", itemText = "";
  const output = [];

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    Logger.log(`\n--- 行${i + 1}の処理開始: ${line}`);
    let matchedAny = false;
    let m;

    // 請求書風情報
    if (line.startsWith("納品日")) {
      const m = line.match(/(\d{4}\/\d{1,2}\/\d{1,2})/);
      if (m) {
        date = m[1];
        Logger.log(`納品日を検出: ${date}`);
      }
    }
    if (line.startsWith("広告主")) {
      client = line.replace("広告主", "").trim();
      Logger.log(`広告主を検出: ${client}`);
    }
    if (line.startsWith("案件名")) {
      project = line.replace("案件名", "").trim();
      Logger.log(`案件名を検出: ${project}`);
    }
    if (line.startsWith("内容")) {
      const contentPattern = /内容\s+(.+?)\s+単価\s+数量\s+金額\s+課税区分\s+¥([\d,]+)\s+([\d,]+)\s+¥([\d,]+)/g;
      let mLine;
      let found = false;
      while ((mLine = contentPattern.exec(line)) !== null) {
        const name = mLine[1].trim();
        const unit = parseInt(mLine[2].replace(/,/g, ''), 10);
        const qty = parseInt(mLine[3].replace(/,/g, ''), 10);
        const amount = parseInt(mLine[4].replace(/,/g, ''), 10);
        Logger.log(`内容一行形式を検出: 商品名=${name}, 単価=${unit}, 件数=${qty}, 金額=${amount}`);
        output.push(["", "", "", name, unit, qty, amount]);
        found = true;
      }
      if (found) {
        continue;
      }

      // ヘッダー行のみで数値が次行に続くパターン
      const headerMatch = line.match(/^内容\s+(.+?)\s+単価\s+数量\s+金額/);
      if (headerMatch) {
        itemText = headerMatch[1].trim();
        Logger.log(`内容ヘッダーを検出: ${itemText}`);
      } else {
        itemText = line.replace("内容", "").trim();
        Logger.log(`内容行を検出: ${itemText}`);
      }
      continue;
    }

    // パターン①：AF成果形式
    const afPattern = /(.+?)[：:]\s*(\d+(?:,\d+)*)件\s*×\s*([\d,]+)円/g;
    let afMatch;
    let afMatched = false;
    while ((afMatch = afPattern.exec(line)) !== null) {
      const name = afMatch[1].trim();
      const qty = parseInt(afMatch[2].replace(/,/g, ''), 10);
      const unit = parseInt(afMatch[3].replace(/,/g, ''), 10);
      Logger.log(`AF成果形式を検出: 商品名=${name}, 件数=${qty}, 単価=${unit}`);
      output.push(["", "", "", name, unit, qty, ""]);
      afMatched = true;
      matchedAny = true;
    }
    if (afMatched) continue;

    // パターン②：再生数課金形式
    m = line.match(/^・(.+?)\s+¥([\d,]+).*?（([\d,]+)再生×([\d.]+)円）/);
    if (m) {
      const name = m[1].trim();
      Logger.log(`再生数課金形式を検出: 商品名=${name}`);
      // 件数と単価は手入力とするため空欄を出力
      output.push(["", "", "", name, "", "", ""]);
      matchedAny = true;
      continue;
    }

    // パターン③：日付付き明細
    m = line.match(/^(\d{4}\/\d{2}\/\d{2})\s+(.+?)\s+¥([\d,]+)\s+(\d+(?:,\d+)*)\s+¥([\d,]+)/);
    if (m) {
      const dt = m[1];
      const name = m[2];
      const unit = parseInt(m[3].replace(/,/g, ''), 10);
      const qty = parseInt(m[4].replace(/,/g, ''), 10);
      Logger.log(`日付付き明細を検出: 日付=${dt}, 商品名=${name.trim()}, 件数=${qty}, 単価=${unit}`);
      output.push([dt, "", "", name.trim(), unit, qty, ""]);
      matchedAny = true;
      continue;
    }

    // パターン④：単価と件数を括弧で表記した明細
    const qtyInParenPattern = /(.+?)\s+¥([\d,]+)\s*\((\d+)\)\s+¥([\d,]+)/g;
    let qpMatch;
    let qpMatched = false;
    while ((qpMatch = qtyInParenPattern.exec(line)) !== null) {
      const name = qpMatch[1].trim();
      const unit = parseInt(qpMatch[2].replace(/,/g, ''), 10);
      const qty = parseInt(qpMatch[3].replace(/,/g, ''), 10);
      const amount = parseInt(qpMatch[4].replace(/,/g, ''), 10);
      Logger.log(`単価と件数括弧形式を検出: 商品名=${name}, 件数=${qty}, 単価=${unit}, 金額=${amount}`);
      output.push(["", "", "", name, unit, qty, amount]);
      qpMatched = true;
      matchedAny = true;
    }
    if (qpMatched) continue;

    // パターン⑤：商品名 単価 件数 金額 の明細
    m = line.match(/^(.+?)\s+¥?([\d,]+)\s+([\d,]+)\s+¥?([\d,]+)/);
    if (m) {
      const name = m[1].trim();
      const unit = parseInt(m[2].replace(/,/g, ''), 10);
      const qty = parseInt(m[3].replace(/,/g, ''), 10);
      const amount = parseInt(m[4].replace(/,/g, ''), 10);
      Logger.log(`商品名単価件数形式を検出: 商品名=${name}, 単価=${unit}, 件数=${qty}, 金額=${amount}`);
      output.push(["", "", "", name, unit, qty, amount]);
      matchedAny = true;
      continue;
    }

    // パターン⑥：商品名 件数 単価 金額 または件数と金額が逆の明細
    m = line.match(/^(.+?)\s+(\d+)\s+¥?([\d,]+)\s+¥?([\d,]+)/);
    if (m) {
      const name = m[1].trim();
      const val1 = parseInt(m[2].replace(/,/g, ''), 10);
      const unit = parseInt(m[3].replace(/,/g, ''), 10);
      const val3 = parseInt(m[4].replace(/,/g, ''), 10);
      let qty, amount;
      if (val1 > val3) {
        amount = val1;
        qty = val3;
      } else {
        qty = val1;
        amount = val3;
      }
      Logger.log(`シンプル明細を検出: 商品名=${name}, 件数=${qty}, 単価=${unit}, 金額=${amount}`);
      output.push(["", "", "", name, unit, qty, amount]);
      matchedAny = true;
      continue;
    }

    // パターン⑦：請求書風明細
    m = line.match(/^¥([\d,]+)\s+([\d,]+)\s+¥([\d,]+)/);
    if (m && itemText) {
      const unit = parseInt(m[1].replace(/,/g, ''), 10);
      const qty = parseInt(m[2].replace(/,/g, ''), 10);
      const amount = parseInt(m[3].replace(/,/g, ''), 10);
      const names = itemText.split("、").map(n => n.trim());
      for (let name of names) {
        Logger.log(
          `請求書風明細を検出: 日付=${date}, 広告主=${client}, 案件名=${project}, 商品名=${name}, 単価=${unit}, 件数=${qty}, 金額=${amount}`
        );
        output.push([date, client, project, name, unit, qty, amount]);
      }
      matchedAny = true;
      continue;
    }

    if (!matchedAny) {
      Logger.log(`パターンにマッチしませんでした: ${line}`);
    }
  }

  // 単価が同じかつ項目名が5文字以上一致する行を集計
  const aggregated = [];
  function hasCommonSubstring(a, b, minLen = 5) {
    if (!a || !b) return false;
    const shorter = a.length <= b.length ? a : b;
    const longer = a.length > b.length ? a : b;
    for (let i = 0; i <= shorter.length - minLen; i++) {
      const sub = shorter.substring(i, i + minLen);
      if (longer.includes(sub)) return true;
    }
    return false;
  }
  for (const row of output) {
    const unit = row[4];
    const name = row[3];
    let merged = false;
    if (unit !== "") {
      for (let i = 0; i < aggregated.length; i++) {
        const aRow = aggregated[i];
        if (aRow[4] === unit && hasCommonSubstring(aRow[3], name, 5)) {
          aRow[5] += Number(row[5]) || 0;
          aRow[6] += Number(row[6]) || 0;
          merged = true;
          break;
        }
      }
    }
    if (!merged) {
      aggregated.push([
        row[0],
        row[1],
        row[2],
        name,
        unit,
        Number(row[5]) || 0,
        Number(row[6]) || 0,
      ]);
    }
  }

  // 出力：ヘッダー付き
  outputSheet.clearContents();
  Logger.log(`抽出完了: ${aggregated.length}件のレコード`);
  if (aggregated.length > 0) {
    outputSheet.getRange(1, 1, 1, 7).setValues([["日付", "広告主", "案件名", "商品名", "単価", "件数", "金額"]]);
    outputSheet.getRange(2, 1, aggregated.length, 7).setValues(aggregated);

    const formulas = [];
    for (let i = 0; i < aggregated.length; i++) {
      formulas.push([`=E${i + 2}*F${i + 2}`]);
    }
    outputSheet.getRange(2, 7, aggregated.length, 1).setFormulas(formulas);

    const sumRow = aggregated.length + 2;
    outputSheet.getRange(sumRow, 7).setFormula(`=SUM(G2:G${sumRow - 1})`);
  } else {
    outputSheet.getRange("A1").setValue("抽出データが見つかりませんでした。");
  }
}
